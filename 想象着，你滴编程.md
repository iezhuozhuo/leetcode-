[TOC]

##### 字符串的全排序

[字符串全排列算法学习](https://www.cnblogs.com/cxjchen/p/3932949.html)

```c++
class solution{
    public:
    void swap(string& str, int i, int j){
        char temp = str[i];
        str[i] = str[j];
        str[j] = temp;
    }
    bool is_swap(string str, int begin, int p){
        bool flag = 1;
        for(int i = begin;i < p;i++){
            if(str[i] == str[p]){
                flag = 0;
               	break;
            }
        }
        return flag;
    }
    vector<string> permutation(string str){
        if(str.size() == 0){
            return vector<string>();
        }
        vector<string>res;
        perm(str, 0, str.size() - 1, res);
        sort(res.begin(),res.end()); // 这样做出来的不是有序字符串
        return res;
    }
    void perm(string& str, int p, int q, vector<string>& res){
        if(p == q){
            res.push_back(str);
        }
        else{
            for(int i = p;i <= q;i++){
                if(is_swap(str, p, i)){
                    swap(str, i, p);
                    perm(str, p+1, q, res);
                    swap(str, i, p);
                }
            }
        }
    }
}
```

#### 链表相关

##### 旋转数组专题

> 给定一个数组，将数组中的元素向右移动 *k* 个位置，其中 *k* 是非负数。$ \color{red}{√} $
>
> 来源：[力扣（LeetCode）189](https://leetcode-cn.com/problems/rotate-array)

> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。$ \color{red}{√} $
>
> 来源：[力扣（LeetCode） 33](https://leetcode-cn.com/problems/search-in-rotated-sorted-array )

> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。(有重复的数字) $ \color{red}{√} $
>
> 来源：[力扣（LeetCode）81](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii)

> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。请找出其中最小的元素。你可以假设数组中不存在重复元素。$ \color{red}{√} $
>
> 来源：[力扣（LeetCode）153](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array ) 以及 [剑指offer](<https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tPage=1>)

> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。请找出其中最小的元素。**注意数组中可能存在重复的元素**。 $ \color{red}{√} $
>
> 来源：[力扣（LeetCode）154](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii)

##### 合并数组/链表相关

> 合并数组：
>
> 1）将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
>
> 来源：[力扣（LeetCode） 21](<https://leetcode-cn.com/problems/merge-two-sorted-lists/>) 
>
> 2）合并 *k* 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。
>
> 来源：[力扣（LeetCode） 23](<https://leetcode-cn.com/problems/merge-k-sorted-lists/>) 

> 合并链表：
>
> 1）给定两个有序整数数组 *nums1* 和 *nums2*，将 *nums2* 合并到 *nums1* 中*，*使得 *num1* 成为一个有序数组。
>
> 来源：[力扣（LeetCode）88](<https://leetcode-cn.com/problems/merge-sorted-array/>) 

##### 链表删除相关

> **删除列表重复值 I** $ \color{red}{√} $
>
> 给定一个排序链表，删除所有重复的元素，使得**每个元素只出现一次**。
>
> 该题需要考虑**野指针**的问题，能够减少空间开销
>
> [力扣 83](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/) 
>
> **删除列表重复值 II** $ \color{red}{√} $
>
> 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 **没有重复出现**的数字。
>
> [力扣 82](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/) 

> **怪异链表的删除** I $ \color{red}{√} $
>
> 请编写一个函数，使其可以删除某个链表中给定的（**非末尾**）节点，你将只被给定要求被删除的节点。
>
> 主要是不是删除最后的尾节点，直接后一个节点的next和val覆盖即可
>
> [力扣 237](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/) 
>
> **怪异链表的删除 II** $ \color{red}{√} $
>
> 请编写一个函数，使其可以删除某个链表中给定的节点，你将只被给定要求被删除的节点。
>
> 包括所有节点的删除，此时倘若删除的是尾节点那么必须**已知头节点，不能直接赋值NULL**

> **删除倒数第k个节点** $ \color{red}{√} $
>
> 给定一个链表，删除链表的倒数第 k 个节点，并且返回链表的头结点。
>
> [力扣 19](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/) 

##### 链表反转相关

> **反转链表 I** $ \color{red}{√} $
>
> [力扣 206](https://leetcode-cn.com/problems/reverse-linked-list/) 
>
> **反转链表 II** $ \color{red}{√} $
>
> 反转从位置 *m* 到 *n* 的链表。请使用一趟扫描完成反转。有一个注意点，需要判断是否是从头开始反转。
>
> [力扣 92](https://leetcode-cn.com/problems/reverse-linked-list-ii/) 

> **旋转数组**
>
> 给定一个链表，旋转链表，将链表每个节点向右移动 *k* 个位置，其中 *k* 是非负数。
>
> 来源：[力扣（LeetCode）61](https://leetcode-cn.com/problems/rotate-list) 

链表排序相关

> **对链表进行插入排序**
>
> 对链表进行插入排序。
>
> [力扣 147](https://leetcode-cn.com/problems/insertion-sort-list/) 

> **重排链表**
>
> 给定一个单链表 L：$L_0→L_1→…→L_n-1→L_n，$
> 将其重新排列后变为： $L_0→L_n→L_1→L_{n-1}→L_2→L_{n-2}→…$
>
> 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
>
> [力扣 143](https://leetcode-cn.com/problems/reorder-list/)

##### 斐波那契数列相关

> **求斐波那契数列的第n项** $ \color{red}{√} $
>
> n = 0, f(n) = 0; n = 1, f(n) = 1; n >= 2 f(n) = f(n - 1) + f(n - 2).
>
> 解法有三种：（1）递归(一般不使用，递归栈太多)时间复杂度$O(N^2)$ （2）循环执行归纳表达式(推荐使用)时间复杂度$O(N)$ （3）见问题转化成求矩阵的N次方问题(代码复杂)时间复杂度$O(logN)$
>
> [力扣 509](https://leetcode-cn.com/problems/fibonacci-number/)
> [剑指](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

> **爬楼梯 I** $ \color{red}{√} $
>
> 解法同上面的斐波那契数列，但是初始值不同
>
> [力扣 70](https://leetcode-cn.com/problems/climbing-stairs/submissions/) 
>
> [剑指](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)
>
> **爬楼梯 II** $ \color{red}{√} $
>
> 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
>
> 解法：求出$2^{n-1}$
>
> [剑指](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

> **牧场还有多少头牛** $ \color{red}{√} $
>
> 假设农场中成熟的母牛每年只会生一头小母牛，并且永远不会死。第一年农场有１只成熟的牛，从第二年开始，母牛开始生小母牛。每只小母牛３年之后 成熟又可以生小母牛。给定整数Ｎ，返回Ｎ年后牛的数量。 f(N) = f(N - 1) + f(N - 3)
>
> 来源：程序员面试指南 P186 

#### 动态规划

##### 数组中递增序列

> **最长连续递增序列**
>
> 给定一个未经排序的整数数组，找到最长且**连续**的的递增序列。
>
> $\color{red}{双指针解法，即维护一个窗口。特殊情况是有重复的数字(算一次)}​$
>
> [力扣 674](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/) 
>
> **递增子序列**
>
> 给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。
>
> $\color{red}{DFS解法，类似于全排列但是要去重使用set}$ 
>
> [力扣 491](https://leetcode-cn.com/problems/increasing-subsequences/) 
>
> **最长递增子序列的个数**
>
> 给定一个未排序的整数数组，找到最长递增子序列的个数。
>
> 用$length[i]$表示以$nums[i]$为结尾的递推序列的长度，用$count[i]$表示以$nums[i]$为结尾的递推序列的个数，初始化都赋值为1，只要有数字，那么至少都是1。  然后我们遍历数组，对于每个遍历到的数字$nums[i]$，我们再遍历其之前的所有数字$nums[j]$，当$nums[i]$小于等于$nums[j]$时，不做任何处理，因为不是递增序列。反之，则判断$length[i]$和$length[j]$的关系，如果$length[i]$等于$length[j] + 1$，说明$nums[i]$这个数字可以加在以$nums[j]$结尾的递增序列后面，并且以$nums[j]$结尾的递增序列个数可以直接加到以$nums[i]$结尾的递增序列个数上。如果$length[i]$小于$length[j] + 1$，说明我们找到了一条长度更长的递增序列，那么我们此时奖$length[i]$更新为$length[j]+1$，并且原本的递增序列都不能用了，直接用$count[j]$来代替。维护一个全局最长的子序列长度$max\_len$，每次都进行更新，到最后遍历一遍每个节点，如果长度等于$max\_len,res+=count[i]$
>
> [力扣 673](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/) 
>
> **最大子序和**
>
> 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> 两种做法（1）$O(N)$ 动态序列；（2）$O(N)$ 来自于编程珠玑，[证明](<https://blog.csdn.net/zwzsdy/article/details/80029796>) $\color{red}这两种解法的写法类似但是从不同角度理解就会有不同的偏差$ 
>
> -----另外有三种遍历字串或者子序列的方法----
>
> (1)以某个节点为开头的所有子序列: 如 `[a]`，`[a, b]`，`[ a, b, c]` ... 再从以 `b` 为开头的子序列开始遍历 `[b] [b, c]` 
>
> (2)根据子序列的长度为标杆，如先遍历出子序列长度为 1 的子序列，在遍历出长度为 2 的 等等
>
> (3)以子序列的结束节点为基准，先遍历出以某个节点为结束的所有子序列，因为每个节点都可能会是子序列的结束节点，因此要遍历下整个序列，如: 以 b 为结束点的所有子序列: `[a , b] [b]` 以` c` 为结束点的所有子序列: `[a, b, c] [b, c] [ c ]`。
>
> [力扣 53](<https://leetcode-cn.com/problems/maximum-subarray/>) 
###### **买卖股票六道题**

解法参考 [🔗](<https://blog.csdn.net/b515833/article/details/93927055>) 

**题1[买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)**

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

> 

**题2 [买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)**

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**题3 [买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)**

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

**题4 [买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)**

给定一个数组，它的第 *i* 个元素是一支给定的股票在第 *i* 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。

**题5 [最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)**

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票)

**题6 [买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)** 

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。

###### **[最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)** 

给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 *O(n)*。

$\color{red}{该题的解法有两种，第一种对数组排序；第二种使用unordered\_set，对num-1查找}​$ 

> $\color{red}{解法1}​$ ：
>
> 在我们开始算法之前，首先检查输入的数组是否为空数组，如果是，函数直接返回 0 。对于其他情况，我们将 nums 数组排序，并考虑除了第一个数字以外的每个数字与它前一个数字的关系。如果当前数字和前一个数字相等，那么我们当前的序列既不会增长也不会中断，我们只需要继续考虑下一个数字。如果不相等，我们必须要检查当前数字是否能延长答案序列（也就是 nums[i] == nums[i-1] + 1）。如果可以增长，那么我们将当前数字添加到当前序列并继续。否则，当前序列被中断，我们记录当前序列的长度并将序列长度重置为 1 。由于 nums 中的最后一个数字也可能是答案序列的一部分，所以我们将当前序列的长度和记录下来的最长序列的长度的较大值返回。

##### 数组跳跃类

> **使用最小花费爬楼梯**
>
> 数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost\[i\](索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯.您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。
>
> [力扣 746](https://leetcode-cn.com/problems/min-cost-climbing-stairs)

> **跳跃游戏 I**
>
> 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。
>
> [力扣 55](https://leetcode-cn.com/problems/jump-game/) 
>
>  **跳跃游戏 II**
>
> 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。
>
> [力扣 45](https://leetcode-cn.com/problems/jump-game-ii) 

#### 二叉树

##### 符合某种相同条件的子树

**相同的树** $ \color{red}{√} $

给定两个二叉树，编写一个函数来检验它们是否相同

[力扣 100](https://leetcode-cn.com/problems/same-tree/) 

###### 另一个相同的子树 I $ \color{red}{√} $

给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

> $\color{red} 本题关键在于相同的定义，指的是子结构要包含所有的子孙$  

[力扣 572](https://leetcode-cn.com/problems/subtree-of-another-tree) 

###### **另一个相同的子树 II** $ \color{red}{√} $

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

> $\color{red} 本题与上一题的区别是包含子结构即可返回$ 

[剑指](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking) 

###### 二叉树的镜像 $ \color{red}{√} $

操作给定的二叉树，将其变换为源二叉树的镜像。

[剑指](https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking) 

###### [判断是否是对称二叉树](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking) $ \color{red}{√} $

请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 

#### 位运算

##### 位运算

> **不用额外变量交换两个整数的值** $ \color{red}{√} $
>
> 偶数次的异或可以消除信息，奇数次的异或可以捕捉信息。
>
> ```c++
> a = a ^ b;
> b = a ^ b;
> a = a ^ b;
> ```

> **统计出整数二进制中含有多少个**1 $ \color{red}{√} $
>
> 解题题眼是：n -= n & (~n + 1)
> n & (~n + 1)的作用是找到最右侧的1的位置，~n + 1是n的相反数(不管是对有符号还是无符号都管用)
>
> [力扣 191](https://leetcode-cn.com/problems/number-of-1-bits/submissions/) [剑指](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

> **数值的整数次方** $ \color{red}{√} $
>
> 解题的题眼是：要充分考虑到(1)base与0.0的关系(尤其是浮点数)；(2)指数为0或者负数时的情况。
>
> [剑指](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tPage=1) 

#### 数学

##### 求根

正常求根，有时候会跟牛顿法一起提及

> 牛顿迭代法，也称牛顿切线法：先任意设定一个与真实的根接近的值x0作为第一次近似根，由x0求出f(x0),过(x0，f(x0))点做f(x)的切线，交x轴于x1，把它作为第二次近似根，再由x1求出f(x1),过(x1，f(x1))点做f(x)的切线，交x轴于x2，……如此继续下去，直到足够接近（比如|x- x0|<1e-6时）真正的根x*为止。
>
> **公式**：f '(x0) = f(x0) / ( x0- x1)  
>
> [参考](<https://blog.csdn.net/morixinguan/article/details/50647555>)



